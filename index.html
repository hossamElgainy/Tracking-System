<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        #map {
            height: 600px;
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .driver-info-window,
        .order-info-window {
            font-family: Arial, sans-serif;
            padding: 8px;
        }

        .driver-info-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #0d6efd;
        }

        .order-info-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #6f42c1;
        }

        .assigned-driver {
            color: #dc3545;
            font-weight: bold;
        }

        .online-badge {
            background-color: #198754;
        }

        .offline-badge {
            background-color: #dc3545;
        }

        .assignment-line {
            stroke: #dc3545;
            stroke-width: 2;
            stroke-dasharray: 5, 5;
        }

        .control-panel {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 5px;
            background-color: #e9ecef;
        }

        .driver-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .loading-spinner {
            display: none;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 0, 0, .1);
            border-radius: 50%;
            border-top-color: #0d6efd;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div class="container mt-4">
        <h1 class="text-center mb-4">Driver Assignment System</h1>

        <div class="control-panel">
            <div class="row">
                <div class="col-md-6">
                    <button id="fetchDriversBtn" class="btn btn-primary">
                        <span id="fetchDriversText">Fetch Available Drivers</span>
                        <div id="fetchDriversSpinner" class="loading-spinner ms-2"></div>
                    </button>
                    <button id="connectDriversBtn" class="btn btn-success ms-2" disabled>
                        <span id="connectDriversText">Connect Drivers</span>
                        <div id="connectDriversSpinner" class="loading-spinner ms-2"></div>
                    </button>
                    <button id="disconnectDriversBtn" class="btn btn-danger ms-2" disabled>Disconnect All</button>
                </div>
                <div class="col-md-6">
                    <div class="mb-3">
                        <label for="broadcastMessage" class="form-label">Broadcast Message</label>
                        <input type="text" class="form-control" id="broadcastMessage"
                            placeholder="Message for all drivers">
                    </div>
                    <button id="broadcastBtn" class="btn btn-warning" disabled>Broadcast</button>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-8">
                <div class="card mb-3">
                    <div class="card-body p-0">
                        <div id="map"></div>
                    </div>
                </div>

                <div class="card mb-3">
                    <div class="card-body">
                        <h4 class="card-title">Order Management</h4>
                        <div class="mb-3">
                            <label for="orderIdInput" class="form-label">Order ID</label>
                            <div class="input-group">
                                <input type="text" class="form-control" id="orderIdInput" placeholder="Enter order ID">
                                <button id="fetchOrderBtn" class="btn btn-primary" type="button">
                                    <span id="fetchOrderText">Fetch Order</span>
                                    <div id="fetchOrderSpinner" class="loading-spinner ms-2"></div>
                                </button>
                            </div>
                        </div>
                        <div class="row mb-3">
                            <div class="col">
                                <label for="orderLatInput" class="form-label">Latitude</label>
                                <input type="number" step="0.000001" class="form-control" id="orderLatInput"
                                    placeholder="Will be filled automatically" readonly>
                            </div>
                            <div class="col">
                                <label for="orderLngInput" class="form-label">Longitude</label>
                                <input type="number" step="0.000001" class="form-control" id="orderLngInput"
                                    placeholder="Will be filled automatically" readonly>
                            </div>
                        </div>
                        <button id="showOrderBtn" class="btn btn-primary" disabled>Show Order on Map</button>
                    </div>
                </div>

                <div id="assignmentDetails" class="card mb-3" style="display:none;">
                    <div class="card-body">
                        <h5 class="card-title">Assignment Details</h5>
                        <div id="assignmentInfo"></div>
                        <button id="confirmAssignmentBtn" class="btn btn-success mt-2">Confirm Assignment</button>
                    </div>
                </div>
            </div>

            <div class="col-md-4">
                <div class="status">
                    <h4>Connection Status</h4>
                    <div id="connectionStatus" class="mb-3 alert alert-secondary">Not connected</div>

                    <h4>Available Drivers (from DB)</h4>
                    <div class="driver-list card mb-3">
                        <div class="card-body">
                            <ul id="availableDriversList" class="list-group mb-3"></ul>
                        </div>
                    </div>

                    <h4>Connected Drivers</h4>
                    <div class="driver-list card mb-3">
                        <div class="card-body">
                            <ul id="connectedDriversList" class="list-group mb-3"></ul>
                        </div>
                    </div>

                    <div class="col-md-12">
                        <div class="card">
                            <div class="card-header bg-primary text-white">
                                <h5 class="card-title mb-0">Online Drivers</h5>
                            </div>
                            <div class="card-body p-0">
                                <div class="list-group list-group-flush" id="onlineDrivers"
                                    style="max-height: 400px; overflow-y: auto;">
                                    <!-- Drivers will appear here -->
                                    <div class="list-group-item text-center text-muted py-4" id="noDriversMessage">
                                        <i class="bi bi-person-x fs-4"></i>
                                        <p class="mt-2 mb-0">No drivers online</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <h4 class="mt-3">Log Messages</h4>
                    <div id="logMessages" class="card bg-light" style="height: 200px; overflow-y: auto; padding: 10px;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Google Maps API -->
    <script
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDF_z09jF2xYrH_Pl-5ekypZt1JtzYd33o&libraries=geometry&callback=initMap"
        async defer></script>
    <script>
        // Global variables
        let connection;
        let map;
        const driverMarkers = {};
        const driverConnections = new Map();
        const infoWindows = {};
        const orderMarkers = {};
        const assignmentLines = {};
        let currentOrder = null;
        let currentAssignment = null;
        let availableDrivers = [];
        const onlineDrivers = new Map(); // Tracks: {driverId: {lat, lng, name, lastUpdate}}

        const colors = [
            '#0d6efd', '#198754', '#dc3545', '#ffc107',
            '#0dcaf0', '#6610f2', '#fd7e14', '#20c997',
            '#6f42c1', '#d63384', '#fd7e14', '#20c997'
        ];
        const driverNameCache = new Map();

        function initMap() {
            map = new google.maps.Map(document.getElementById("map"), {
                center: { lat: 29.9514, lng: 30.9247 },
                zoom: 12,
                mapTypeControl: true,
                streetViewControl: false,
                fullscreenControl: true,
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels",
                        stylers: [{ visibility: "off" }]
                    }
                ]
            });

            map.setOptions({
                minZoom: 3,
                maxZoom: 18
            });

            logMessage("Map initialized - Ready to track drivers");
            setupConnection();
        }

        // Initialize SignalR connection
        function setupConnection() {
            connection = new signalR.HubConnectionBuilder()
                .withUrl(`http://laundry.runasp.net/driverHub`)
                .withAutomaticReconnect()
                .configureLogging(signalR.LogLevel.Information)
                .build();

            // Connection events
            connection.onclose(async () => {
                updateConnectionStatus("Disconnected", "alert-danger");
                logMessage("Connection lost. Attempting to reconnect...");
            });

            connection.onreconnecting(error => {
                updateConnectionStatus("Reconnecting...", "alert-warning");
                logMessage(`Connection lost. Reconnecting... Error: ${error}`);
            });

            connection.onreconnected(connectionId => {
                updateConnectionStatus("Connected", "alert-success");
                logMessage(`Reconnected with ID: ${connectionId}`);
            });

            // Handle location updates
            connection.on("ReceiveLocationUpdate", (driverId, lat, lng, timestamp, driverName) => {
                logMessage(`Location update for driver ${driverId}: ${lat}, ${lng}`);
                updateDriverMarker(driverId, lat, lng, driverName);
            });

            connection.on("DriverOnline", (driverId, driverName) => {
                logMessage(`Driver ${driverId} (${driverName}) came online`);
                if (!onlineDrivers.has(driverId)) {
                    onlineDrivers.set(driverId, {
                        id: driverId,
                        name: driverName || `Driver ${driverId}`,
                        lat: 0,
                        lng: 0,
                        lastUpdate: null
                    });
                    requestDriverLocation(driverId); // Request initial location
                }
                updateOnlineDriversList();
            });

            connection.on("DriverOffline", (driverId) => {
                logMessage(`Driver ${driverId} went offline`);
                onlineDrivers.delete(driverId);
                removeDriverMarker(driverId);
                updateOnlineDriversList();
            });

            connection.on("ReceiveBroadcast", (message) => {
                logMessage(`Broadcast message: ${message}`);
                showNotification(`Broadcast: ${message}`);
            });

            // New event handler for order assignment confirmation
            connection.on("OrderAssigned", (orderId, driverId) => {
                logMessage(`Order ${orderId} has been assigned to driver ${driverId}`);
                showNotification(`Order ${orderId} assigned to driver ${driverId}`);
                
                // Update the order marker to show it's assigned
                if (orderMarkers[orderId]) {
                    orderMarkers[orderId].setIcon({
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 8,
                        fillColor: '#198754', // Green for assigned
                        fillOpacity: 1,
                        strokeWeight: 2,
                        strokeColor: '#FFFFFF'
                    });
                }
                
                // Reset the driver marker
                if (driverMarkers[driverId]) {
                    const colorIndex = parseInt(driverId.replace('R', '')) % colors.length;
                    const color = colors[colorIndex];
                    driverMarkers[driverId].setIcon({
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 10,
                        fillColor: color,
                        fillOpacity: 0.9,
                        strokeWeight: 2,
                        strokeColor: 'white'
                    });
                }
                
                // Remove assignment line if exists
                if (assignmentLines[orderId]) {
                    assignmentLines[orderId].setMap(null);
                    delete assignmentLines[orderId];
                }
                
                // Reset current assignment
                currentAssignment = null;
                document.getElementById('assignmentDetails').style.display = 'none';
            });

            startConnection();
        }

        async function fetchInitialDriverLocations() {
            try {
                if (connection.state !== signalR.HubConnectionState.Connected) {
                    console.warn("SignalR connection is not connected. Retrying...");
                    await startConnection();
                }

                const locations = await connection.invoke("GetAllDriverLocations");
                console.log("Initial driver locations:", locations);

                Object.entries(locations).forEach(([driverId, location]) => {
                    updateDriverMarker(
                        driverId,
                        location.Latitude,
                        location.Longitude,
                        location.DriverName || `Driver ${driverId}`
                    );
                });

                updateOnlineDriversList();
            } catch (error) {
                console.error("Error fetching driver locations:", error);
                setTimeout(fetchInitialDriverLocations, 3000);
            }
        }

        function updateOnlineDriversList() {
            const list = document.getElementById("onlineDrivers");
            const noDriversMsg = document.getElementById("noDriversMessage");

            // Clear existing list
            list.innerHTML = '';

            if (onlineDrivers.size === 0) {
                noDriversMsg.style.display = 'block';
                return;
            }

            noDriversMsg.style.display = 'none';

            onlineDrivers.forEach((driver, driverId) => {
                const item = document.createElement("div");
                item.className = "list-group-item list-group-item-action";
                item.innerHTML = `
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <h6 class="mb-0">${driver.name}</h6>
                    <small class="text-muted">${driverId}</small>
                </div>
                <div>
                    <span class="badge bg-success rounded-pill">Online</span>
                    <button class="btn btn-sm btn-outline-primary ms-2 show-driver-btn" 
                            data-driver-id="${driverId}">
                        <i class="bi bi-eye"></i> Show
                    </button>
                </div>
            </div>
        `;
                list.appendChild(item);
            });

            // Add event listeners to all show buttons
            document.querySelectorAll('.show-driver-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const driverId = e.currentTarget.getAttribute('data-driver-id');
                    centerOnDriver(driverId);
                });
            });
        }

        function updateDriverMarker(driverId, lat, lng, driverName) {
            const position = { lat: parseFloat(lat), lng: parseFloat(lng) };

            // Update driver in onlineDrivers map
            if (onlineDrivers.has(driverId)) {
                const driver = onlineDrivers.get(driverId);
                driver.lat = position.lat;
                driver.lng = position.lng;
                driver.lastUpdate = new Date();
            }

            if (!driverMarkers[driverId]) {
                // Create new marker if it doesn't exist
                driverMarkers[driverId] = new google.maps.Marker({
                    position,
                    map,
                    title: driverName || `Driver ${driverId}`,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 10,
                        fillColor: getDriverColor(driverId),
                        fillOpacity: 0.9,
                        strokeWeight: 2,
                        strokeColor: 'white'
                    }
                });

                // Add click listener
                driverMarkers[driverId].addListener("click", () => {
                    showDriverInfoWindow(driverId, position.lat, position.lng, driverName);
                });
            } else {
                // Update existing marker's position
                driverMarkers[driverId].setPosition(position);
                driverMarkers[driverId].setTitle(driverName || `Driver ${driverId}`);
            }

            // Log the update for debugging
            console.log(`Updated driver ${driverId} position to ${lat}, ${lng}`);
        }

        // Helper function to get a consistent color for each driver
        function getDriverColor(driverId) {
            // Simple hash function to get consistent color for each driver
            let hash = 0;
            for (let i = 0; i < driverId.length; i++) {
                hash = driverId.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }

        // Request location update for a specific driver
        async function requestDriverLocation(driverId) {
            try {
                await connection.invoke("RequestDriverLocation", driverId);
            } catch (error) {
                console.error("Error requesting location:", error);
            }
        }

        function showDriverInfoWindow(driverId, lat, lng, driverName) {
            // Close any existing info window for this driver
            if (infoWindows[driverId]) {
                infoWindows[driverId].close();
            }

            // Create new info window
            infoWindows[driverId] = new google.maps.InfoWindow({
                content: createDriverInfoContent(driverName, driverId, lat, lng)
            });

            // Open the info window at the driver's marker
            if (driverMarkers[driverId]) {
                infoWindows[driverId].open(map, driverMarkers[driverId]);
            } else {
                logMessage(`Driver ${driverId} marker not found when trying to show info window`);
            }
        }

        function createDriverInfoContent(driverName, driverId, lat, lng) {
            return `
        <div class="driver-info-window p-2">
            <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="mb-0">${driverName}</h6>
                <span class="badge bg-success">Online</span>
            </div>
            <div class="mb-2"><small class="text-muted">ID: ${driverId}</small></div>
            
            <div class="mb-2">
                <div class="fw-bold">Current Location:</div>
                <div>Lat: ${lat.toFixed(6)}</div>
                <div>Lng: ${lng.toFixed(6)}</div>
            </div>
            
            <div class="d-grid gap-2 mt-3">
                ${currentOrder ? `
                <button class="btn btn-sm btn-primary" 
                        onclick="assignToOrder('${driverId}')">
                    Assign to Current Order
                </button>
                ` : ''}
                <button class="btn btn-sm btn-outline-secondary" 
                        onclick="centerOnDriver('${driverId}')">
                    Center Map
                </button>
            </div>
        </div>
    `;
        }

        async function startConnection() {
            try {
                await connection.start();
                updateConnectionStatus("Connected", "alert-success");
                logMessage("SignalR connection established");

                // Enable buttons
                document.getElementById("disconnectDriversBtn").disabled = false;
                document.getElementById("broadcastBtn").disabled = false;
                // Fetch initial driver locations
                await fetchInitialDriverLocations();
            } catch (err) {
                logMessage(`Connection error: ${err}`);
                setTimeout(startConnection, 5000);
            }
        }

        // Fetch available drivers from database
        async function fetchAvailableDrivers() {
            try {
                // Show loading spinner
                document.getElementById("fetchDriversText").textContent = "Fetching...";
                document.getElementById("fetchDriversSpinner").style.display = "inline-block";

                // Fetch drivers from API
                const response = await fetch('http://laundry.runasp.net/api/Drivers/GetDrivers');
                const data = await response.json();

                if (response.ok) {
                    availableDrivers = data.data || [];
                    updateAvailableDriversList();
                    document.getElementById("connectDriversBtn").disabled = false;
                    logMessage(`Fetched ${availableDrivers.length} available drivers from database`);
                } else {
                    throw new Error(data.message || "Failed to fetch drivers");
                }
            } catch (error) {
                logMessage(`Error fetching drivers: ${error.message}`);
                showNotification(`Error: ${error.message}`);
            } finally {
                // Hide loading spinner
                document.getElementById("fetchDriversText").textContent = "Fetch Available Drivers";
                document.getElementById("fetchDriversSpinner").style.display = "none";
            }
        }

        // Update available drivers list display
        function updateAvailableDriversList() {
            const list = document.getElementById("availableDriversList");
            list.innerHTML = '';

            availableDrivers.forEach(driver => {
                const li = document.createElement("li");
                li.className = "list-group-item d-flex justify-content-between align-items-center";
                li.dataset.driverId = driver.id;
                li.innerHTML = `
                    ${driver.fullName}
                    <span class="badge bg-secondary">${driver.id}</span>
                `;
                list.appendChild(li);
            });
        }

        // Connect all available drivers
        async function connectAllDrivers() {
            try {
                // Show loading spinner
                document.getElementById("connectDriversText").textContent = "Connecting...";
                document.getElementById("connectDriversSpinner").style.display = "inline-block";

                // Clear existing connections
                driverConnections.forEach((_, driverId) => {
                    driverConnections.delete(driverId);
                    removeOnlineDriver(driverId);
                    removeDriverMarker(driverId);
                });

                // Add new drivers
                for (const driver of availableDrivers) {
                    if (!driverConnections.has(driver.id)) {
                        driverConnections.set(driver.id, true);
                        driverNameCache.set(driver.id, driver.fullName);

                        // Create initial marker first
                        updateDriverMarker(
                            driver.id,
                            29.9514 + (Math.random() * 0.1 - 0.05), // Initial lat
                            30.9247 + (Math.random() * 0.1 - 0.05), // Initial lng
                            driver.fullName
                        );

                        // Then add to online list
                        addOnlineDriver(driver.id);

                        // Then start movement simulation
                        simulateDriverMovement(driver.id);
                    }
                }
                updateConnectedDriversList();
                logMessage(`Connected ${availableDrivers.length} drivers`);

            } catch (error) {
                logMessage(`Error connecting drivers: ${error.message}`);
            } finally {
                // Hide loading spinner
                document.getElementById("connectDriversText").textContent = "Connect Drivers";
                document.getElementById("connectDriversSpinner").style.display = "none";
            }
        }

        // Update connected drivers list display
        function updateConnectedDriversList() {
            const list = document.getElementById("connectedDriversList");
            list.innerHTML = '';

            driverConnections.forEach((_, driverId) => {
                const driverName = driverNameCache.get(driverId) || driverId;
                const li = document.createElement("li");
                li.className = "list-group-item d-flex justify-content-between align-items-center";
                li.dataset.driverId = driverId;
                li.innerHTML = `
                    ${driverName}
                    <div>
                        <span class="badge ${isDriverOnline(driverId) ? 'online-badge' : 'offline-badge'} rounded-pill">
                            ${isDriverOnline(driverId) ? 'Online' : 'Offline'}
                        </span>
                        <button class="btn btn-sm btn-outline-danger ms-2" 
                                onclick="disconnectDriver('${driverId}')">Remove</button>
                    </div>
                `;
                list.appendChild(li);
            });
        }

        // Check if driver is online
        function isDriverOnline(driverId) {
            return Array.from(document.getElementById("onlineDrivers").children)
                .some(li => li.dataset.driverId === driverId);
        }

        // Disconnect individual driver
        window.disconnectDriver = function (driverId) {
            driverConnections.delete(driverId);
            removeOnlineDriver(driverId);
            removeDriverMarker(driverId);
            updateConnectedDriversList();
            logMessage(`Disconnected driver ${driverId}`);
        };

        // Driver simulation
        function simulateDriverMovement(driverId) {
            if (!connection || connection.state !== signalR.HubConnectionState.Connected) return;

            let lat = 29.9514 + (Math.random() * 0.1 - 0.05);
            let lng = 30.9247 + (Math.random() * 0.1 - 0.05);
            let heading = Math.random() * 360;

            const interval = setInterval(() => {
                if (!driverConnections.has(driverId)) {
                    clearInterval(interval);
                    return;
                }

                const distance = 0.001 + Math.random() * 0.002;
                lat += distance * Math.cos(heading * Math.PI / 180);
                lng += distance * Math.sin(heading * Math.PI / 180);
                heading += (Math.random() * 30 - 15);

                connection.invoke("SendLocationUpdate", driverId, lat, lng)
                    .catch(err => console.error("Send failed:", err));

            }, 3000 + Math.random() * 2000);
        }

        // Fetch order details from database
        async function fetchOrderDetails(orderId) {
            try {
                // Show loading spinner
                document.getElementById("fetchOrderText").textContent = "Fetching...";
                document.getElementById("fetchOrderSpinner").style.display = "inline-block";

                // Fetch order from API
                const response = await fetch(`http://laundry.runasp.net/api/orders/GetOrderById?OrderId=${orderId}`);
                const data = await response.json();
                console.log(data);
                if (response.ok) {
                    return {
                        id: orderId,
                        lat: data.lat,
                        lng: data.lang,
                        address: data.address || "Address not specified"
                    };
                } else {
                    throw new Error(data.message || "Failed to fetch order details");
                }
            } catch (error) {
                logMessage(`Error fetching order: ${error.message}`);
                showNotification(`Error: ${error.message}`);
                return null;
            } finally {
                // Hide loading spinner
                document.getElementById("fetchOrderText").textContent = "Fetch Order";
                document.getElementById("fetchOrderSpinner").style.display = "none";
            }
        }

        // Distance calculation
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // Distance in km
        }

        // Order management functions
        async function showOrderOnMap(order) {
            // Remove any existing order marker
            if (orderMarkers[order.id]) {
                orderMarkers[order.id].setMap(null);
            }

            // Create new order marker
            orderMarkers[order.id] = new google.maps.Marker({
                position: { lat: order.lat, lng: order.lng },
                map: map,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: '#FF00FF',
                    fillOpacity: 1,
                    strokeWeight: 2,
                    strokeColor: '#FFFFFF'
                },
                title: `Order ${order.id}`
            });

            // Create info window
            const infoWindow = new google.maps.InfoWindow({
                content: createOrderInfoContent(order)
            });

            orderMarkers[order.id].addListener('click', () => {
                infoWindow.open(map, orderMarkers[order.id]);
            });

            // Center map on order
            map.panTo({ lat: order.lat, lng: order.lng });
            map.setZoom(14);

            // Set as current order
            currentOrder = order;

            // Highlight nearby drivers
            highlightNearbyDrivers(order.lat, order.lng);

            logMessage(`Showing order ${order.id} on map. Click a driver to assign.`);
        }

        function highlightNearbyDrivers(orderLat, orderLng) {
            resetAllDriverMarkers();

            driverConnections.forEach((_, driverId) => {
                const marker = driverMarkers[driverId];
                if (marker) {
                    const driverPos = marker.getPosition();
                    const distance = calculateDistance(orderLat, orderLng, driverPos.lat(), driverPos.lng());

                    if (distance < 5) { // Within 5km
                        marker.setIcon({
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 10,
                            fillColor: '#FFA500',
                            fillOpacity: 1,
                            strokeWeight: 2,
                            strokeColor: '#FFFFFF'
                        });

                        marker.addListener('click', () => {
                            assignDriverToOrder(currentOrder.id, driverId);
                        });
                    }
                }
            });
        }

        function resetAllDriverMarkers() {
            driverConnections.forEach((_, driverId) => {
                if (driverMarkers[driverId]) {
                    const colorIndex = parseInt(driverId.replace('R', '')) % colors.length;
                    const color = colors[colorIndex];

                    driverMarkers[driverId].setIcon({
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 10,
                        fillColor: color,
                        fillOpacity: 0.9,
                        strokeWeight: 2,
                        strokeColor: 'white'
                    });

                    google.maps.event.clearListeners(driverMarkers[driverId], 'click');
                }
            });
        }

       assignDriverToOrder// In admin.html script
async function assignDriverToOrder(orderId, driverId) {
    try {
        // Show loading state
        document.getElementById("confirmAssignmentBtn").disabled = true;
        document.getElementById("confirmAssignmentBtn").innerHTML = `
            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
            Assigning...
        `;

        // Get order details from API
        const orderResponse = await fetch(`http://laundry.runasp.net/api/orders/GetOrderById?OrderId=${orderId}`);
        if (!orderResponse.ok) throw new Error("Failed to fetch order details");
        const order = await orderResponse.json();

        // Prepare assignment data
        const assignmentData = {
            orderId: order.id,
            customerName: order.customer?.fullName || "Customer",
            address: order.deliveryAddress,
            totalPrice: order.totalPrice,
            pickupLocation: {
                lat: order.lat,
                lng: order.lang
            }
        };

        // Assign via SignalR
        await connection.invoke("AssignOrder", driverId, orderId, assignmentData);
        
        showNotification(`Order ${orderId} assigned to driver ${driverId}`, "success");
        logMessage(`Order ${orderId} assigned to driver ${driverId}`);

        // Update UI
        if (orderMarkers[orderId]) {
            orderMarkers[orderId].setIcon({
                path: google.maps.SymbolPath.CIRCLE,
                scale: 8,
                fillColor: '#198754', // Green for assigned
                fillOpacity: 1,
                strokeWeight: 2,
                strokeColor: '#FFFFFF'
            });
        }

        // Remove assignment line if exists
        if (assignmentLines[orderId]) {
            assignmentLines[orderId].setMap(null);
            delete assignmentLines[orderId];
        }

    } catch (error) {
        console.error("Assignment error:", error);
        showNotification(`Assignment failed: ${error.message}`, "danger");
        logMessage(`Assignment failed: ${error.message}`);
    } finally {
        document.getElementById("confirmAssignmentBtn").disabled = false;
        document.getElementById("confirmAssignmentBtn").innerHTML = 'Confirm Assignment';
        document.getElementById('assignmentDetails').style.display = 'none';
    }
}
        function drawAssignmentLine(orderId, driverId, driverPos) {
            if (assignmentLines[orderId]) {
                assignmentLines[orderId].setMap(null);
            }

            assignmentLines[orderId] = new google.maps.Polyline({
                path: [
                    { lat: currentOrder.lat, lng: currentOrder.lng },
                    { lat: driverPos.lat(), lng: driverPos.lng() }
                ],
                geodesic: true,
                strokeColor: '#FF0000',
                strokeOpacity: 1.0,
                strokeWeight: 2,
                strokeDashArray: [5, 5],
                map: map
            });
        }

        function showAssignmentDetails(assignment) {
            document.getElementById('assignmentInfo').innerHTML = `
                <p><strong>Order ID:</strong> ${assignment.orderId}</p>
                <p><strong>Driver:</strong> ${assignment.driverName} (${assignment.driverId})</p>
                <p><strong>Distance:</strong> ${assignment.distance.toFixed(2)} km</p>
            `;
            document.getElementById('assignmentDetails').style.display = 'block';

            // Center map on driver
            map.panTo(assignment.position);
        }

        // Function to actually assign the order via API
        async function confirmOrderAssignment(assignment) {
            try {
                // Show loading state
                document.getElementById("confirmAssignmentBtn").disabled = true;
                document.getElementById("confirmAssignmentBtn").innerHTML = `
            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
            Assigning...
        `;

                // Prepare the request
                const requestBody = {
                    orderId: parseInt(assignment.orderId),
                    deliveryId: assignment.driverId
                };

                // Make the API call
                const response = await fetch('http://laundry.runasp.net/api/OrderDeliveries', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `API returned ${response.status}`);
                }

                const data = await response.json();
                const order = currentOrder || await fetchOrderDetails(assignment.orderId);
                // Notify the driver via SignalR
                try {
                    await connection.invoke("AssignOrder", assignment.driverId, assignment.orderId, {
                        orderId: assignment.orderId,
                        pickupLocation: {
                            lat: order.lat,
                            lng: order.lng
                        },
                        address: order.address
                    });
                } catch (error) {
                    console.error("Error notifying driver:", error);
                    logMessage(`Order assigned but could not notify driver: ${error.message}`);
                }

                // Update UI for successful assignment
                showNotification(`Success! Order ${assignment.orderId} assigned to ${assignment.driverName}`);
                logMessage(`Order ${assignment.orderId} successfully assigned to driver ${assignment.driverId}`);

                // Update the order marker to show it's assigned
                if (orderMarkers[assignment.orderId]) {
                    orderMarkers[assignment.orderId].setIcon({
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 8,
                        fillColor: '#198754', // Green for assigned
                        fillOpacity: 1,
                        strokeWeight: 2,
                        strokeColor: '#FFFFFF'
                    });

                    // Update info window
                    const infoWindow = new google.maps.InfoWindow({
                        content: createAssignedOrderInfoContent(assignment)
                    });

                    orderMarkers[assignment.orderId].addListener('click', () => {
                        infoWindow.open(map, orderMarkers[assignment.orderId]);
                    });
                }

                // Reset driver marker
                if (driverMarkers[assignment.driverId]) {
                    const colorIndex = parseInt(assignment.driverId.replace('R', '')) % colors.length;
                    const color = colors[colorIndex];

                    driverMarkers[assignment.driverId].setIcon({
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 10,
                        fillColor: color,
                        fillOpacity: 0.9,
                        strokeWeight: 2,
                        strokeColor: 'white'
                    });
                }

                // Remove assignment line
                if (assignmentLines[assignment.orderId]) {
                    assignmentLines[assignment.orderId].setMap(null);
                    delete assignmentLines[assignment.orderId];
                }

                // Reset assignment UI
                document.getElementById('assignmentDetails').style.display = 'none';
                currentAssignment = null;

            } catch (error) {
                logMessage(`Assignment failed: ${error.message}`);
                showNotification(`Error assigning order: ${error.message}`);
            } finally {
                // Reset button state
                document.getElementById("confirmAssignmentBtn").disabled = false;
                document.getElementById("confirmAssignmentBtn").innerHTML = 'Confirm Assignment';
            }
        }

        // Create content for assigned order info window
        function createAssignedOrderInfoContent(assignment) {
            return `
                <div class="order-info-window">
                    <div class="order-info-title">Order ${assignment.orderId} (Assigned)</div>
                    <div><strong>Assigned to:</strong> ${assignment.driverName}</div>
                    <div><strong>Driver ID:</strong> ${assignment.driverId}</div>
                    <div><strong>Distance:</strong> ${assignment.distance.toFixed(2)} km</div>
                    <div><strong>Status:</strong> <span class="badge bg-success">Assigned</span></div>
                    <div><strong>Assigned at:</strong> ${new Date().toLocaleTimeString()}</div>
                </div>
            `;
        }

        // Content creation functions
        function createOrderInfoContent(order) {
            return `
                <div class="order-info-window">
                    <div class="order-info-title">Order ${order.id}</div>
                    <div><strong>Address:</strong> ${order.address}</div>
                    <div><strong>Location:</strong></div>
                    <div>Lat: ${order.lat.toFixed(6)}</div>
                    <div>Lng: ${order.lng.toFixed(6)}</div>
                    <div><strong>Status:</strong> <span class="badge bg-secondary">Pending Assignment</span></div>
                </div>
            `;
        }

        function createAssignedDriverInfoContent(driverName, driverId, orderId, distance) {
            return `
                <div class="driver-info-window">
                    <div class="driver-info-title assigned-driver">${driverName} (ASSIGNED)</div>
                    <div><small>ID: ${driverId}</small></div>
                    <div><strong>Assigned to order:</strong> ${orderId}</div>
                    <div><strong>Distance to client:</strong> ${distance.toFixed(2)} km</div>
                    <div><strong>Assigned at:</strong> ${new Date().toLocaleTimeString()}</div>
                </div>
            `;
        }

        // Driver information functions
        async function updateDriverPosition(driverId, lat, lng, timestamp) {
            const driverName = driverNameCache.get(driverId) || driverId;
            const position = { lat, lng };
            const colorIndex = parseInt(driverId.replace('R', '')) % colors.length;
            const color = colors[colorIndex];

            if (driverMarkers[driverId]) {
                driverMarkers[driverId].setPosition(position);
                driverMarkers[driverId].setTitle(driverName);
                if (infoWindows[driverId]) {
                    infoWindows[driverId].setContent(
                        createDriverInfoContent(driverName, driverId, lat, lng, timestamp)
                    );
                }
            } else {
                driverMarkers[driverId] = new google.maps.Marker({
                    position,
                    map,
                    title: driverName,
                    label: {
                        text: driverName.split(' ').map(n => n[0]).join(''),
                        color: 'white',
                        fontSize: '12px',
                        fontWeight: 'bold'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 10,
                        fillColor: color,
                        fillOpacity: 0.9,
                        strokeWeight: 2,
                        strokeColor: 'white'
                    },
                    animation: google.maps.Animation.DROP
                });

                infoWindows[driverId] = new google.maps.InfoWindow({
                    content: createDriverInfoContent(driverName, driverId, lat, lng, timestamp)
                });

                driverMarkers[driverId].addListener("click", () => {
                    Object.values(infoWindows).forEach(iw => iw.close());
                    infoWindows[driverId].open(map, driverMarkers[driverId]);
                });
            }
        }

        function createDriverInfoContent(driverName, driverId, lat, lng) {
            return `
        <div class="driver-info-window p-2">
            <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="mb-0">${driverName}</h6>
                <span class="badge bg-success">Online</span>
            </div>
            <div class="mb-2"><small class="text-muted">ID: ${driverId}</small></div>
            
            <div class="mb-2">
                <div class="fw-bold">Current Location:</div>
                <div>Lat: ${lat.toFixed(6)}</div>
                <div>Lng: ${lng.toFixed(6)}</div>
            </div>
            
            <div class="d-grid gap-2 mt-3">
                <button class="btn btn-sm btn-primary" 
                        onclick="assignToOrder('${driverId}')">
                    <i class="bi bi-truck"></i> Assign Order
                </button>
                <button class="btn btn-sm btn-outline-secondary" 
                        onclick="centerOnDriver('${driverId}')">
                    <i class="bi bi-geo-alt"></i> Center Map
                </button>
            </div>
        </div>
    `;
        }

        // UI management functions
        async function addOnlineDriver(driverId) {
            const list = document.getElementById("onlineDrivers");

            if (!Array.from(list.children).some(li => li.dataset.driverId === driverId)) {
                const li = document.createElement("li");
                li.className = "list-group-item d-flex justify-content-between align-items-center";
                li.dataset.driverId = driverId;
                li.innerHTML = `
                    ${driverNameCache.get(driverId) || driverId}
                    <div>
                        <span class="badge online-badge rounded-pill">Online</span>
                        <button class="btn btn-sm btn-outline-primary ms-2" 
                                onclick="centerOnDriver('${driverId}')">Show</button>
                    </div>
                `;
                list.appendChild(li);
            }
            updateConnectedDriversList();
        }

        function removeOnlineDriver(driverId) {
            const list = document.getElementById("onlineDrivers");
            Array.from(list.children).forEach(li => {
                if (li.dataset.driverId === driverId) {
                    list.removeChild(li);
                }
            });
            updateConnectedDriversList();
        }

        function removeDriverMarker(driverId) {
            if (driverMarkers[driverId]) {
                driverMarkers[driverId].setMap(null);
                delete driverMarkers[driverId];
            }
            if (infoWindows[driverId]) {
                infoWindows[driverId].close();
                delete infoWindows[driverId];
            }
        }

        // Center map on driver
        window.centerOnDriver = function (driverId) {
            try {
                const matchingKey = Object.keys(driverMarkers).find(key => key.includes(driverId));

                if (matchingKey) {
                    console.log('Found matching key:', matchingKey);
                    const position = driverMarkers[matchingKey].getPosition();
                    map.panTo(position);
                    map.setZoom(15);
                    showDriverInfoWindow(
                        matchingKey,
                        position.lat(),
                        position.lng(),
                        driverMarkers[matchingKey].getTitle()
                    );
                } else {
                    logMessage(`Driver ${driverId} marker not found. Available markers: ${Object.keys(driverMarkers).join(', ')}`);
                }
            } catch (error) {
                console.error('Error in centerOnDriver:', error);
                logMessage(`Error focusing on driver: ${error.message}`);
            }
        };

        // Assign driver to current order
        window.assignToOrder = function (driverId) {
            if (currentOrder) {
                assignDriverToOrder(currentOrder.id, driverId);
            } else {
                alert("Please select an order first");
            }
        };

        function updateConnectionStatus(status, alertClass) {
            const statusDiv = document.getElementById("connectionStatus");
            statusDiv.textContent = status;
            statusDiv.className = `alert ${alertClass} mb-3`;
        }

        function logMessage(message) {
            const logDiv = document.getElementById("logMessages");
            const entry = document.createElement("div");
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function showNotification(message) {
            const notification = document.createElement("div");
            notification.className = "alert alert-info position-fixed top-0 end-0 m-3";
            notification.style.zIndex = "1000";
            notification.style.width = "300px";
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 5000);
        }

        // Event listeners
        document.getElementById("fetchDriversBtn").addEventListener("click", fetchAvailableDrivers);

        document.getElementById("connectDriversBtn").addEventListener("click", connectAllDrivers);

        document.getElementById("disconnectDriversBtn").addEventListener("click", async () => {
            if (connection) {
                await connection.stop();
                driverConnections.clear();
                document.getElementById("connectedDriversList").innerHTML = '';
                document.getElementById("onlineDrivers").innerHTML = '';
                Object.values(driverMarkers).forEach(marker => marker.setMap(null));
                Object.values(infoWindows).forEach(iw => iw.close());
                document.getElementById("connectDriversBtn").disabled = true;
                document.getElementById("disconnectDriversBtn").disabled = true;
                document.getElementById("broadcastBtn").disabled = true;
                updateConnectionStatus("Disconnected", "alert-danger");
                logMessage("Disconnected all drivers from hub");
            }
        });

        document.getElementById("broadcastBtn").addEventListener("click", async () => {
            const message = document.getElementById("broadcastMessage").value.trim();

            if (message) {
                try {
                    await connection.invoke("SendMessageToAllDrivers", message);
                    logMessage(`Broadcast message sent`);
                } catch (err) {
                    logMessage(`Error broadcasting message: ${err}`);
                }
            }
        });

        document.getElementById("fetchOrderBtn").addEventListener("click", async () => {
            const orderId = document.getElementById("orderIdInput").value.trim();

            if (!orderId) {
                alert("Please enter an order ID");
                return;
            }

            const order = await fetchOrderDetails(orderId);
            if (order) {
                // Fill the latitude and longitude fields
                document.getElementById("orderLatInput").value = order.lat
                document.getElementById("orderLngInput").value = order.lng;

                // Enable the "Show Order on Map" button
                document.getElementById("showOrderBtn").disabled = false;

                // Store the order details
                currentOrder = order;

                logMessage(`Fetched order ${orderId} details from database`);
            }
        });

        document.getElementById("showOrderBtn").addEventListener("click", () => {
            if (!currentOrder) {
                alert("No order data available");
                return;
            }

            showOrderOnMap(currentOrder);
        });

        document.getElementById("confirmAssignmentBtn").addEventListener("click", () => {
            if (currentAssignment) {
                confirmOrderAssignment(currentAssignment);
                logMessage(`Confirmed assignment: Driver ${currentAssignment.driverId} assigned to order ${currentAssignment.orderId}`);
                showNotification(`Assignment confirmed!\nDriver: ${currentAssignment.driverName}\nOrder: ${currentAssignment.orderId}`);

                // Reset UI
                document.getElementById("assignmentDetails").style.display = 'none';
                currentOrder = null;
                currentAssignment = null;
            }
        });
    </script>
</body>

</html>