<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Driver Assignment System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        #map {
            height: 600px;
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .driver-info-window, .order-info-window {
            font-family: Arial, sans-serif;
            padding: 8px;
        }
        .driver-info-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #0d6efd;
        }
        .order-info-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #6f42c1;
        }
        .assigned-driver {
            color: #dc3545;
            font-weight: bold;
        }
        .online-badge {
            background-color: #198754;
        }
        .offline-badge {
            background-color: #dc3545;
        }
        .assignment-line {
            stroke: #dc3545;
            stroke-width: 2;
            stroke-dasharray: 5, 5;
        }
        .control-panel {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 5px;
            background-color: #e9ecef;
        }
        .driver-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        .loading-spinner {
            display: none;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,.1);
            border-radius: 50%;
            border-top-color: #0d6efd;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container mt-4">
        <h1 class="text-center mb-4">Driver Assignment System</h1>
        
        <div class="control-panel">
            <div class="row">
                <div class="col-md-6">
                    <button id="fetchDriversBtn" class="btn btn-primary">
                        <span id="fetchDriversText">Fetch Available Drivers</span>
                        <div id="fetchDriversSpinner" class="loading-spinner ms-2"></div>
                    </button>
                    <button id="connectDriversBtn" class="btn btn-success ms-2" disabled>
                        <span id="connectDriversText">Connect Drivers</span>
                        <div id="connectDriversSpinner" class="loading-spinner ms-2"></div>
                    </button>
                    <button id="disconnectDriversBtn" class="btn btn-danger ms-2" disabled>Disconnect All</button>
                </div>
                <div class="col-md-6">
                    <div class="mb-3">
                        <label for="broadcastMessage" class="form-label">Broadcast Message</label>
                        <input type="text" class="form-control" id="broadcastMessage" placeholder="Message for all drivers">
                    </div>
                    <button id="broadcastBtn" class="btn btn-warning" disabled>Broadcast</button>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-8">
                <div class="card mb-3">
                    <div class="card-body p-0">
                        <div id="map"></div>
                    </div>
                </div>
                
                <div class="card mb-3">
                    <div class="card-body">
                        <h4 class="card-title">Order Management</h4>
                        <div class="mb-3">
                            <label for="orderIdInput" class="form-label">Order ID</label>
                            <div class="input-group">
                                <input type="text" class="form-control" id="orderIdInput" placeholder="Enter order ID">
                                <button id="fetchOrderBtn" class="btn btn-primary" type="button">
                                    <span id="fetchOrderText">Fetch Order</span>
                                    <div id="fetchOrderSpinner" class="loading-spinner ms-2"></div>
                                </button>
                            </div>
                        </div>
                        <div class="row mb-3">
                            <div class="col">
                                <label for="orderLatInput" class="form-label">Latitude</label>
                                <input type="number" step="0.000001" class="form-control" id="orderLatInput" placeholder="Will be filled automatically" readonly>
                            </div>
                            <div class="col">
                                <label for="orderLngInput" class="form-label">Longitude</label>
                                <input type="number" step="0.000001" class="form-control" id="orderLngInput" placeholder="Will be filled automatically" readonly>
                            </div>
                        </div>
                        <button id="showOrderBtn" class="btn btn-primary" disabled>Show Order on Map</button>
                    </div>
                </div>

                <div id="assignmentDetails" class="card mb-3" style="display:none;">
                    <div class="card-body">
                        <h5 class="card-title">Assignment Details</h5>
                        <div id="assignmentInfo"></div>
                        <button id="confirmAssignmentBtn" class="btn btn-success mt-2" >Confirm Assignment</button>
                    </div>
                </div>
            </div>
            
            <div class="col-md-4">
                <div class="status">
                    <h4>Connection Status</h4>
                    <div id="connectionStatus" class="mb-3 alert alert-secondary">Not connected</div>
                    
                    <h4>Available Drivers (from DB)</h4>
                    <div class="driver-list card mb-3">
                        <div class="card-body">
                            <ul id="availableDriversList" class="list-group mb-3"></ul>
                        </div>
                    </div>
                    
                    <h4>Connected Drivers</h4>
                    <div class="driver-list card mb-3">
                        <div class="card-body">
                            <ul id="connectedDriversList" class="list-group mb-3"></ul>
                        </div>
                    </div>
                    
                    <h4>Online Drivers</h4>
                    <ul id="onlineDrivers" class="list-group mb-3"></ul>
                    
                    <h4 class="mt-3">Log Messages</h4>
                    <div id="logMessages" class="card bg-light" style="height: 200px; overflow-y: auto; padding: 10px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDw2L54vytvX214rcrejbI9T-tqZDI58xE&callback=initMap" async defer></script>

    <script>
        // Global variables
        let connection;
        let map;
        const driverMarkers = {};
        const driverConnections = new Map();
        const infoWindows = {};
        const orderMarkers = {};
        const assignmentLines = {};
        let currentOrder = null;
        let currentAssignment = null;
        let availableDrivers = [];
        
        const colors = [
            '#0d6efd', '#198754', '#dc3545', '#ffc107', 
            '#0dcaf0', '#6610f2', '#fd7e14', '#20c997',
            '#6f42c1', '#d63384', '#fd7e14', '#20c997'
        ];
        const driverNameCache = new Map();

        // Initialize the map
        function initMap() {
            map = new google.maps.Map(document.getElementById("map"), {
                center: { lat: 29.9514, lng: 30.9247 },
                zoom: 12,
                mapTypeControl: true,
                streetViewControl: false,
                fullscreenControl: true,
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels",
                        stylers: [{ visibility: "off" }]
                    }
                ]
            });
            
            map.setOptions({
                minZoom: 3,
                maxZoom: 18
            });
            
            logMessage("Map initialized - Ready to track drivers");
            
            // Initialize SignalR connection
            setupConnection();
        }

        // Initialize SignalR connection
        function setupConnection() {
            connection = new signalR.HubConnectionBuilder()
                .withUrl(`https://laundry.runasp.net/driverHub`)
                .withAutomaticReconnect()
                .configureLogging(signalR.LogLevel.Information)
                .build();

            // Connection events
            connection.onclose(async () => {
                updateConnectionStatus("Disconnected", "alert-danger");
                logMessage("Connection lost. Attempting to reconnect...");
            });

            connection.onreconnecting(error => {
                updateConnectionStatus("Reconnecting...", "alert-warning");
                logMessage(`Connection lost. Reconnecting... Error: ${error}`);
            });

            connection.onreconnected(connectionId => {
                updateConnectionStatus("Connected", "alert-success");
                logMessage(`Reconnected with ID: ${connectionId}`);
            });

            // Hub methods
            connection.on("ReceiveLocationUpdate", (driverId, lat, lng, timestamp) => {
                updateDriverPosition(driverId, lat, lng, timestamp);
                logMessage(`Location update for ${driverId} at ${new Date(timestamp).toLocaleTimeString()}`);
            });

            connection.on("DriverOnline", (driverId) => {
                if (!driverConnections.has(driverId)) {
                    driverConnections.set(driverId, true);
                    addOnlineDriver(driverId);
                    logMessage(`Driver ${driverId} came online`);
                }
            });

            connection.on("DriverOffline", (driverId) => {
                if (driverConnections.has(driverId)) {
                    driverConnections.delete(driverId);
                    removeOnlineDriver(driverId);
                    removeDriverMarker(driverId);
                    logMessage(`Driver ${driverId} went offline`);
                }
            });

            connection.on("ReceiveBroadcast", (message) => {
                logMessage(`Broadcast message: ${message}`);
                showNotification(`Broadcast: ${message}`);
            });

            startConnection();
        }

        async function startConnection() {
            try {
                await connection.start();
                updateConnectionStatus("Connected", "alert-success");
                logMessage("SignalR connection established");
                
                // Enable buttons
                document.getElementById("disconnectDriversBtn").disabled = false;
                document.getElementById("broadcastBtn").disabled = false;
                
            } catch (err) {
                logMessage(`Connection error: ${err}`);
                setTimeout(startConnection, 5000);
            }
        }

        // Fetch available drivers from database
        async function fetchAvailableDrivers() {
            try {
                // Show loading spinner
                document.getElementById("fetchDriversText").textContent = "Fetching...";
                document.getElementById("fetchDriversSpinner").style.display = "inline-block";
                
                // Fetch drivers from API
                const response = await fetch('https://laundry.runasp.net/api/Drivers/GetDrivers');
                const data = await response.json();
                console.log(data);

                if (response.ok) {
                    availableDrivers = data.data || [];
                    updateAvailableDriversList();
                    document.getElementById("connectDriversBtn").disabled = false;
                    logMessage(`Fetched ${availableDrivers.length} available drivers from database`);
                } else {
                    throw new Error(data.message || "Failed to fetch drivers");
                }
            } catch (error) {
                logMessage(`Error fetching drivers: ${error.message}`);
                showNotification(`Error: ${error.message}`);
            } finally {
                // Hide loading spinner
                document.getElementById("fetchDriversText").textContent = "Fetch Available Drivers";
                document.getElementById("fetchDriversSpinner").style.display = "none";
            }
        }

        // Update available drivers list display
        function updateAvailableDriversList() {
            const list = document.getElementById("availableDriversList");
            list.innerHTML = '';
            
            availableDrivers.forEach(driver => {
                const li = document.createElement("li");
                li.className = "list-group-item d-flex justify-content-between align-items-center";
                li.dataset.driverId = driver.id;
                li.innerHTML = `
                    ${driver.fullName}
                    <span class="badge bg-secondary">${driver.id}</span>
                `;
                list.appendChild(li);
            });
        }

        // Connect all available drivers
        async function connectAllDrivers() {
            try {
                // Show loading spinner
                document.getElementById("connectDriversText").textContent = "Connecting...";
                document.getElementById("connectDriversSpinner").style.display = "inline-block";
                
                // Clear existing connections
                driverConnections.forEach((_, driverId) => {
                    driverConnections.delete(driverId);
                    removeOnlineDriver(driverId);
                    removeDriverMarker(driverId);
                });
                
                // Add new drivers
                for (const driver of availableDrivers) {
                    if (!driverConnections.has(driver.id)) {
                        driverConnections.set(driver.id, true);
                        driverNameCache.set(driver.id, driver.fullName);
                        addOnlineDriver(driver.id);
                        simulateDriverMovement(driver.id);
                    }
                }
                
                updateConnectedDriversList();
                logMessage(`Connected ${availableDrivers.length} drivers`);
                
            } catch (error) {
                logMessage(`Error connecting drivers: ${error.message}`);
            } finally {
                // Hide loading spinner
                document.getElementById("connectDriversText").textContent = "Connect Drivers";
                document.getElementById("connectDriversSpinner").style.display = "none";
            }
        }

        // Update connected drivers list display
        function updateConnectedDriversList() {
            const list = document.getElementById("connectedDriversList");
            list.innerHTML = '';
            
            driverConnections.forEach((_, driverId) => {
                const driverName = driverNameCache.get(driverId) || driverId;
                const li = document.createElement("li");
                li.className = "list-group-item d-flex justify-content-between align-items-center";
                li.dataset.driverId = driverId;
                li.innerHTML = `
                    ${driverName}
                    <div>
                        <span class="badge ${isDriverOnline(driverId) ? 'online-badge' : 'offline-badge'} rounded-pill">
                            ${isDriverOnline(driverId) ? 'Online' : 'Offline'}
                        </span>
                        <button class="btn btn-sm btn-outline-danger ms-2" 
                                onclick="disconnectDriver('${driverId}')">Remove</button>
                    </div>
                `;
                list.appendChild(li);
            });
        }

        // Check if driver is online
        function isDriverOnline(driverId) {
            return Array.from(document.getElementById("onlineDrivers").children)
                .some(li => li.dataset.driverId === driverId);
        }

        // Disconnect individual driver
        window.disconnectDriver = function(driverId) {
            driverConnections.delete(driverId);
            removeOnlineDriver(driverId);
            removeDriverMarker(driverId);
            updateConnectedDriversList();
            logMessage(`Disconnected driver ${driverId}`);
        };

        // Driver simulation
        function simulateDriverMovement(driverId) {
            if (!connection || connection.state !== signalR.HubConnectionState.Connected) return;
            
            let lat = 29.9514 + (Math.random() * 0.1 - 0.05);
            let lng = 30.9247 + (Math.random() * 0.1 - 0.05);
            let heading = Math.random() * 360;
            
            const interval = setInterval(() => {
                if (!driverConnections.has(driverId)) {
                    clearInterval(interval);
                    return;
                }
                
                const distance = 0.001 + Math.random() * 0.002;
                lat += distance * Math.cos(heading * Math.PI / 180);
                lng += distance * Math.sin(heading * Math.PI / 180);
                heading += (Math.random() * 30 - 15);
                
                connection.invoke("SendLocationUpdate", driverId, lat, lng)
                    .catch(err => console.error("Send failed:", err));
                    
            }, 3000 + Math.random() * 2000);
        }

        // Fetch order details from database
        async function fetchOrderDetails(orderId) {
            try {
                // Show loading spinner
                document.getElementById("fetchOrderText").textContent = "Fetching...";
                document.getElementById("fetchOrderSpinner").style.display = "inline-block";
                
                // Fetch order from API
                const response = await fetch(`https://laundry.runasp.net/api/orders/GetOrderById?OrderId=${orderId}`);
                const data = await response.json();
                console.log(data);
                if (response.ok) {
                    return {
                        id: orderId,
                        lat: data.lat,
                        lng: data.lang,
                        address: data.address || "Address not specified"
                    };
                } else {
                    throw new Error(data.message || "Failed to fetch order details");
                }
            } catch (error) {
                logMessage(`Error fetching order: ${error.message}`);
                showNotification(`Error: ${error.message}`);
                return null;
            } finally {
                // Hide loading spinner
                document.getElementById("fetchOrderText").textContent = "Fetch Order";
                document.getElementById("fetchOrderSpinner").style.display = "none";
            }
        }

        // Distance calculation
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in km
        }

        // Order management functions
        async function showOrderOnMap(order) {
            // Remove any existing order marker
            if (orderMarkers[order.id]) {
                orderMarkers[order.id].setMap(null);
            }
            
            // Create new order marker
            orderMarkers[order.id] = new google.maps.Marker({
                position: { lat: order.lat, lng: order.lng },
                map: map,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: '#FF00FF',
                    fillOpacity: 1,
                    strokeWeight: 2,
                    strokeColor: '#FFFFFF'
                },
                title: `Order ${order.id}`
            });
            
            // Create info window
            const infoWindow = new google.maps.InfoWindow({
                content: createOrderInfoContent(order)
            });
            
            orderMarkers[order.id].addListener('click', () => {
                infoWindow.open(map, orderMarkers[order.id]);
            });
            
            // Center map on order
            map.panTo({ lat: order.lat, lng: order.lng });
            map.setZoom(14);
            
            // Set as current order
            currentOrder = order;
            
            // Highlight nearby drivers
            highlightNearbyDrivers(order.lat, order.lng);
            
            logMessage(`Showing order ${order.id} on map. Click a driver to assign.`);
        }

        function highlightNearbyDrivers(orderLat, orderLng) {
            resetAllDriverMarkers();
            
            driverConnections.forEach((_, driverId) => {
                const marker = driverMarkers[driverId];
                if (marker) {
                    const driverPos = marker.getPosition();
                    const distance = calculateDistance(orderLat, orderLng, driverPos.lat(), driverPos.lng());
                    
                    if (distance < 5) { // Within 5km
                        marker.setIcon({
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 10,
                            fillColor: '#FFA500',
                            fillOpacity: 1,
                            strokeWeight: 2,
                            strokeColor: '#FFFFFF'
                        });
                        
                        marker.addListener('click', () => {
                            assignDriverToOrder(currentOrder.id, driverId);
                        });
                    }
                }
            });
        }

        function resetAllDriverMarkers() {
            driverConnections.forEach((_, driverId) => {
                if (driverMarkers[driverId]) {
                    const colorIndex = parseInt(driverId.replace('R', '')) % colors.length;
                    const color = colors[colorIndex];
                    
                    driverMarkers[driverId].setIcon({
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 10,
                        fillColor: color,
                        fillOpacity: 0.9,
                        strokeWeight: 2,
                        strokeColor: 'white'
                    });
                    
                    google.maps.event.clearListeners(driverMarkers[driverId], 'click');
                }
            });
        }

        async function assignDriverToOrder(orderId, driverId) {
            if (!currentOrder || currentOrder.id !== orderId) {
                logMessage("No active order selected for assignment");
                return;
            }
            
            const driverName = driverNameCache.get(driverId) || driverId;
            const driverPos = driverMarkers[driverId].getPosition();
            const distance = calculateDistance(
                currentOrder.lat,
                currentOrder.lng,
                driverPos.lat(),
                driverPos.lng()
            );
            
            // Update driver marker
            driverMarkers[driverId].setIcon({
                path: google.maps.SymbolPath.CIRCLE,
                scale: 12,
                fillColor: '#FF0000',
                fillOpacity: 1,
                strokeWeight: 2,
                strokeColor: '#FFFFFF'
            });
            
            // Draw assignment line
            drawAssignmentLine(orderId, driverId, driverPos);
            
            // Update info window
            if (infoWindows[driverId]) {
                infoWindows[driverId].setContent(
                    createAssignedDriverInfoContent(driverName, driverId, orderId, distance)
                );
            }
            
            // Store assignment
            currentAssignment = {
                orderId: orderId,
                driverId: driverId,
                driverName: driverName,
                distance: distance,
                position: driverPos
            };
            
            // Show assignment details
            showAssignmentDetails(currentAssignment);
            
            logMessage(`Preparing to assign driver ${driverId} (${driverName}) to order ${orderId}`);
        }

        function drawAssignmentLine(orderId, driverId, driverPos) {
            if (assignmentLines[orderId]) {
                assignmentLines[orderId].setMap(null);
            }
            
            assignmentLines[orderId] = new google.maps.Polyline({
                path: [
                    { lat: currentOrder.lat, lng: currentOrder.lng },
                    { lat: driverPos.lat(), lng: driverPos.lng() }
                ],
                geodesic: true,
                strokeColor: '#FF0000',
                strokeOpacity: 1.0,
                strokeWeight: 2,
                strokeDashArray: [5, 5],
                map: map
            });
        }

        function showAssignmentDetails(assignment) {
            document.getElementById('assignmentInfo').innerHTML = `
                <p><strong>Order ID:</strong> ${assignment.orderId}</p>
                <p><strong>Driver:</strong> ${assignment.driverName} (${assignment.driverId})</p>
                <p><strong>Distance:</strong> ${assignment.distance.toFixed(2)} km</p>
            `;
            document.getElementById('assignmentDetails').style.display = 'block';
            
            // Center map on driver
            map.panTo(assignment.position);
        }

        // NEW: Function to actually assign the order via API
        async function confirmOrderAssignment(assignment) {
    try {
        // Show loading state
        document.getElementById("confirmAssignmentBtn").disabled = true;
        document.getElementById("confirmAssignmentBtn").innerHTML = `
            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
            Assigning...
        `;
        
        // Prepare the request
        const requestBody = {
            orderId: parseInt(assignment.orderId),
            deliveryId: assignment.driverId
        };
        
        // Make the API call
        const response = await fetch('https://laundry.runasp.net/api/OrderDeliveries', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                // Add authorization header if needed
                // 'Authorization': 'Bearer ' + yourAuthToken
            },
            body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `API returned ${response.status}`);
        }
        
        const data = await response.json();
        
        // Update UI for successful assignment
        showNotification(`Success! Order ${assignment.orderId} assigned to ${assignment.driverName}`);
        logMessage(`Order ${assignment.orderId} successfully assigned to driver ${assignment.driverId}`);
        
        // Update the order marker to show it's assigned
        if (orderMarkers[assignment.orderId]) {
            orderMarkers[assignment.orderId].setIcon({
                path: google.maps.SymbolPath.CIRCLE,
                scale: 8,
                fillColor: '#198754', // Green for assigned
                fillOpacity: 1,
                strokeWeight: 2,
                strokeColor: '#FFFFFF'
            });
            
            // Update info window
            const infoWindow = new google.maps.InfoWindow({
                content: createAssignedOrderInfoContent(assignment)
            });
            
            orderMarkers[assignment.orderId].addListener('click', () => {
                infoWindow.open(map, orderMarkers[assignment.orderId]);
            });
        }
        
        // Reset driver marker
        if (driverMarkers[assignment.driverId]) {
            const colorIndex = parseInt(assignment.driverId.replace('R', '')) % colors.length;
            const color = colors[colorIndex];
            
            driverMarkers[assignment.driverId].setIcon({
                path: google.maps.SymbolPath.CIRCLE,
                scale: 10,
                fillColor: color,
                fillOpacity: 0.9,
                strokeWeight: 2,
                strokeColor: 'white'
            });
        }
        
        // Remove assignment line
        if (assignmentLines[assignment.orderId]) {
            assignmentLines[assignment.orderId].setMap(null);
            delete assignmentLines[assignment.orderId];
        }
        
        // Reset assignment UI
        document.getElementById('assignmentDetails').style.display = 'none';
        currentAssignment = null;
        
    } catch (error) {
        logMessage(`Assignment failed: ${error.message}`);
        showNotification(`Error assigning order: ${error.message}`);
    } finally {
        // Reset button state
        document.getElementById("confirmAssignmentBtn").disabled = false;
        document.getElementById("confirmAssignmentBtn").innerHTML = 'Confirm Assignment';
    }
}
        // NEW: Create content for assigned order info window
        function createAssignedOrderInfoContent(assignment) {
            return `
                <div class="order-info-window">
                    <div class="order-info-title">Order ${assignment.orderId} (Assigned)</div>
                    <div><strong>Assigned to:</strong> ${assignment.driverName}</div>
                    <div><strong>Driver ID:</strong> ${assignment.driverId}</div>
                    <div><strong>Distance:</strong> ${assignment.distance.toFixed(2)} km</div>
                    <div><strong>Status:</strong> <span class="badge bg-success">Assigned</span></div>
                    <div><strong>Assigned at:</strong> ${new Date().toLocaleTimeString()}</div>
                </div>
            `;
        }

        // Content creation functions
        function createOrderInfoContent(order) {
            return `
                <div class="order-info-window">
                    <div class="order-info-title">Order ${order.id}</div>
                    <div><strong>Address:</strong> ${order.address}</div>
                    <div><strong>Location:</strong></div>
                    <div>Lat: ${order.lat.toFixed(6)}</div>
                    <div>Lng: ${order.lng.toFixed(6)}</div>
                    <div><strong>Status:</strong> <span class="badge bg-secondary">Pending Assignment</span></div>
                </div>
            `;
        }

        function createAssignedDriverInfoContent(driverName, driverId, orderId, distance) {
            return `
                <div class="driver-info-window">
                    <div class="driver-info-title assigned-driver">${driverName} (ASSIGNED)</div>
                    <div><small>ID: ${driverId}</small></div>
                    <div><strong>Assigned to order:</strong> ${orderId}</div>
                    <div><strong>Distance to client:</strong> ${distance.toFixed(2)} km</div>
                    <div><strong>Assigned at:</strong> ${new Date().toLocaleTimeString()}</div>
                </div>
            `;
        }

        // Driver information functions
        async function updateDriverPosition(driverId, lat, lng, timestamp) {
            const driverName = driverNameCache.get(driverId) || driverId;
            const position = { lat, lng };
            const colorIndex = parseInt(driverId.replace('R', '')) % colors.length;
            const color = colors[colorIndex];
            
            if (driverMarkers[driverId]) {
                driverMarkers[driverId].setPosition(position);
                driverMarkers[driverId].setTitle(driverName);
                if (infoWindows[driverId]) {
                    infoWindows[driverId].setContent(
                        createDriverInfoContent(driverName, driverId, lat, lng, timestamp)
                    );
                }
            } else {
                driverMarkers[driverId] = new google.maps.Marker({
                    position,
                    map,
                    title: driverName,
                    label: {
                        text: driverName.split(' ').map(n => n[0]).join(''),
                        color: 'white',
                        fontSize: '12px',
                        fontWeight: 'bold'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 10,
                        fillColor: color,
                        fillOpacity: 0.9,
                        strokeWeight: 2,
                        strokeColor: 'white'
                    },
                    animation: google.maps.Animation.DROP
                });
                
                infoWindows[driverId] = new google.maps.InfoWindow({
                    content: createDriverInfoContent(driverName, driverId, lat, lng, timestamp)
                });
                
                driverMarkers[driverId].addListener("click", () => {
                    Object.values(infoWindows).forEach(iw => iw.close());
                    infoWindows[driverId].open(map, driverMarkers[driverId]);
                });
            }
        }

        function createDriverInfoContent(driverName, driverId, lat, lng, timestamp) {
            const timeStr = timestamp ? new Date(timestamp).toLocaleTimeString() : 'Just now';
            return `
                <div class="driver-info-window">
                    <div class="driver-info-title">${driverName}</div>
                    <div><small>ID: ${driverId}</small></div>
                    <div><strong>Status:</strong> <span class="badge online-badge">Online</span></div>
                    <div><strong>Last Update:</strong> ${timeStr}</div>
                    <div><strong>Location:</strong></div>
                    <div>Lat: ${lat.toFixed(6)}</div>
                    <div>Lng: ${lng.toFixed(6)}</div>
                </div>
            `;
        }

        // UI management functions
        async function addOnlineDriver(driverId) {
            const list = document.getElementById("onlineDrivers");
            if (!Array.from(list.children).some(li => li.dataset.driverId === driverId)) {
                const li = document.createElement("li");
                li.className = "list-group-item d-flex justify-content-between align-items-center";
                li.dataset.driverId = driverId;
                li.innerHTML = `
                    ${driverNameCache.get(driverId) || driverId}
                    <div>
                        <span class="badge online-badge rounded-pill">Online</span>
                        <button class="btn btn-sm btn-outline-primary ms-2" 
                                onclick="centerOnDriver('${driverId}')">Show</button>
                    </div>
                `;
                list.appendChild(li);
            }
            updateConnectedDriversList();
        }

        function removeOnlineDriver(driverId) {
            const list = document.getElementById("onlineDrivers");
            Array.from(list.children).forEach(li => {
                if (li.dataset.driverId === driverId) {
                    list.removeChild(li);
                }
            });
            updateConnectedDriversList();
        }

        function removeDriverMarker(driverId) {
            if (driverMarkers[driverId]) {
                driverMarkers[driverId].setMap(null);
                delete driverMarkers[driverId];
            }
            if (infoWindows[driverId]) {
                infoWindows[driverId].close();
                delete infoWindows[driverId];
            }
        }

        // Utility functions
        window.centerOnDriver = function(driverId) {
            if (driverMarkers[driverId]) {
                map.panTo(driverMarkers[driverId].getPosition());
                map.setZoom(15);
                if (infoWindows[driverId]) {
                    infoWindows[driverId].open(map, driverMarkers[driverId]);
                }
            }
        };

        function updateConnectionStatus(status, alertClass) {
            const statusDiv = document.getElementById("connectionStatus");
            statusDiv.textContent = status;
            statusDiv.className = `alert ${alertClass} mb-3`;
        }

        function logMessage(message) {
            const logDiv = document.getElementById("logMessages");
            const entry = document.createElement("div");
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function showNotification(message) {
            const notification = document.createElement("div");
            notification.className = "alert alert-info position-fixed top-0 end-0 m-3";
            notification.style.zIndex = "1000";
            notification.style.width = "300px";
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 5000);
        }

        // Event listeners
        document.getElementById("fetchDriversBtn").addEventListener("click", fetchAvailableDrivers);
        
        document.getElementById("connectDriversBtn").addEventListener("click", connectAllDrivers);

        document.getElementById("disconnectDriversBtn").addEventListener("click", async () => {
            if (connection) {
                await connection.stop();
                driverConnections.clear();
                document.getElementById("connectedDriversList").innerHTML = '';
                document.getElementById("onlineDrivers").innerHTML = '';
                Object.values(driverMarkers).forEach(marker => marker.setMap(null));
                Object.values(infoWindows).forEach(iw => iw.close());
                document.getElementById("connectDriversBtn").disabled = true;
                document.getElementById("disconnectDriversBtn").disabled = true;
                document.getElementById("broadcastBtn").disabled = true;
                updateConnectionStatus("Disconnected", "alert-danger");
                logMessage("Disconnected all drivers from hub");
            }
        });

        document.getElementById("broadcastBtn").addEventListener("click", async () => {
            const message = document.getElementById("broadcastMessage").value.trim();
            
            if (message) {
                try {
                    await connection.invoke("SendMessageToAllDrivers", message);
                    logMessage(`Broadcast message sent`);
                } catch (err) {
                    logMessage(`Error broadcasting message: ${err}`);
                }
            }
        });

        document.getElementById("fetchOrderBtn").addEventListener("click", async () => {
            const orderId = document.getElementById("orderIdInput").value.trim();
            
            if (!orderId) {
                alert("Please enter an order ID");
                return;
            }
            
            const order = await fetchOrderDetails(orderId);
            if (order) {
                // Fill the latitude and longitude fields
                document.getElementById("orderLatInput").value = order.lat
                document.getElementById("orderLngInput").value = order.lng;
                
                // Enable the "Show Order on Map" button
                document.getElementById("showOrderBtn").disabled = false;
                
                // Store the order details
                currentOrder = order;
                
                logMessage(`Fetched order ${orderId} details from database`);
            }
        });

        document.getElementById("showOrderBtn").addEventListener("click", () => {
            if (!currentOrder) {
                alert("No order data available");
                return;
            }
            
            showOrderOnMap(currentOrder);
        });

        document.getElementById("confirmAssignmentBtn").addEventListener("click", () => {
            if (currentAssignment) {
                confirmOrderAssignment(currentAssignment);
                logMessage(`Confirmed assignment: Driver ${currentAssignment.driverId} assigned to order ${currentAssignment.orderId}`);
                showNotification(`Assignment confirmed!\nDriver: ${currentAssignment.driverName}\nOrder: ${currentAssignment.orderId}`);
                
                // Reset UI
                document.getElementById("assignmentDetails").style.display = 'none';
                currentOrder = null;
                currentAssignment = null;
            }
        });
    </script>
</body>
</html>