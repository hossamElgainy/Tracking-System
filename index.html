<!DOCTYPE html>
<html lang="en">

<head>
    <title>Tracking System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        #map {
            height: 600px;
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .driver-info-window {
            font-family: Arial, sans-serif;
            padding: 8px;
        }

        .driver-info-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #0d6efd;
        }

        .online-badge {
            background-color: #198754;
        }

        .offline-badge {
            background-color: #dc3545;
        }
    </style>
</head>

<body>
    <div class="container mt-4">
        <h1 class="text-center mb-4">Driver Tracking System</h1>

        <div class="card mb-4">
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="driverIds" class="form-label">Driver IDs (comma separated)</label>
                            <input type="text" class="form-control" id="driverIds" placeholder="R4,R5,R6,R7"
                                value="R4,R5,R6,R7">
                        </div>
                        <button id="connectBtn" class="btn btn-primary">Connect All</button>
                        <button id="disconnectBtn" class="btn btn-danger ms-2" disabled>Disconnect All</button>
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="broadcastMessage" class="form-label">Broadcast Message</label>
                            <input type="text" class="form-control" id="broadcastMessage"
                                placeholder="Message for all drivers">
                        </div>
                        <button id="broadcastBtn" class="btn btn-warning" disabled>Broadcast</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-8">
                <div class="card">
                    <div class="card-body p-0">
                        <div id="map"></div>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card">
                    <div class="card-body">
                        <h4 class="card-title">Connection Status</h4>
                        <div id="connectionStatus" class="mb-3 alert alert-secondary">Not connected</div>
                        <h4 class="card-title">Online Drivers</h4>
                        <ul id="onlineDrivers" class="list-group mb-3"></ul>
                        <h4 class="card-title mt-3">Log Messages</h4>
                        <div id="logMessages" class="card bg-light"
                            style="height: 200px; overflow-y: auto; padding: 10px;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDw2L54vytvX214rcrejbI9T-tqZDI58xE&callback=initMap"
        async defer></script>

    <script>
        // Global variables
        let connection;
        let map;
        const driverMarkers = {};
        const driverConnections = new Map();
        const infoWindows = {};
        const colors = [
            '#0d6efd', '#198754', '#dc3545', '#ffc107',
            '#0dcaf0', '#6610f2', '#fd7e14', '#20c997',
            '#6f42c1', '#d63384', '#fd7e14', '#20c997'
        ];
        const driverNameCache = new Map();

        // Initialize the map with better defaults
        function initMap() {
            map = new google.maps.Map(document.getElementById("map"), {
                center: { lat: 24.7136, lng: 46.6753 }, // Centered on Riyadh
                zoom: 12,
                mapTypeControl: true,
                streetViewControl: false,
                fullscreenControl: true,
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels",
                        stylers: [{ visibility: "off" }]
                    }
                ]
            });

            // Add bounds to prevent zooming out too far
            map.setOptions({
                minZoom: 3,
                maxZoom: 18
            });

            logMessage("Map initialized - Ready to track drivers");
        }

        // Initialize SignalR connection
        async function setupConnection() {
            connection = new signalR.HubConnectionBuilder()
                .withUrl(`https://laundry.runasp.net/driverHub`)
                .withAutomaticReconnect({
                    nextRetryDelayInMilliseconds: retryContext => {
                        return Math.min(retryContext.previousRetryCount * 1000, 10000);
                    }
                })
                .configureLogging(signalR.LogLevel.Information)
                .build();

            // Connection events
            connection.onclose(async () => {
                updateConnectionStatus("Disconnected", "alert-danger");
                logMessage("Connection lost. Attempting to reconnect...");
            });

            connection.onreconnecting(error => {
                updateConnectionStatus("Reconnecting...", "alert-warning");
                logMessage(`Connection lost. Reconnecting... Error: ${error}`);
            });

            connection.onreconnected(connectionId => {
                updateConnectionStatus("Connected", "alert-success");
                logMessage(`Reconnected with ID: ${connectionId}`);

                // Re-establish all driver connections
                const driverIds = document.getElementById("driverIds").value.split(',').map(id => id.trim());
                driverIds.forEach(driverId => {
                    if (driverId && !driverConnections.has(driverId)) {
                        driverConnections.set(driverId, true);
                        addOnlineDriver(driverId);
                    }
                });
            });

            // Hub methods
            connection.on("ReceiveLocationUpdate", (driverId, lat, lng, timestamp) => {
                updateDriverPosition(driverId, lat, lng, timestamp);
                (async () => {
                    logMessage(`Location update for ${await getName(driverId)} at ${new Date().toLocaleTimeString()} - Lat: ${lat.toFixed(6)}, Lng: ${lng.toFixed(6)}`);
                })();
            });

            connection.on("DriverOnline", (driverId) => {
                if (!driverConnections.has(driverId)) {
                    driverConnections.set(driverId, true);
                    addOnlineDriver(driverId);
                    logMessage(`Driver ${driverId} came online`);
                }
            });

            connection.on("DriverOffline", (driverId) => {
                if (driverConnections.has(driverId)) {
                    driverConnections.delete(driverId);
                    removeOnlineDriver(driverId);
                    removeDriverMarker(driverId);
                    logMessage(`Driver ${driverId} went offline`);
                }
            });

            connection.on("ReceiveBroadcast", (message) => {
                logMessage(`Broadcast message: ${message}`);
                showNotification(`Broadcast: ${message}`);
            });

            startConnection();
        }

        async function startConnection() {
            try {
                await connection.start();
                updateConnectionStatus("Connected", "alert-success");
                logMessage("SignalR connection established");

                // Enable buttons
                document.getElementById("disconnectBtn").disabled = false;
                document.getElementById("broadcastBtn").disabled = false;

                // Get initial list of drivers
                const driverIds = document.getElementById("driverIds").value.split(',').map(id => id.trim());
                driverIds.forEach(driverId => {
                    if (driverId) {
                        driverConnections.set(driverId, true);
                        addOnlineDriver(driverId);
                        simulateDriverMovement(driverId);
                    }
                });

            } catch (err) {
                logMessage(`Connection error: ${err}`);
                setTimeout(startConnection, 5000);
            }
        }

        async function getName(driverId) {
            // Check cache first
            if (driverNameCache.has(driverId)) {
                return driverNameCache.get(driverId);
            }

            // Fetch from API
            try {
                const response = await fetch(`https://laundry.runasp.net/api/drivers/GetDriverById?Id=${driverId}`);
                const data = await response.json();

                // Handle the API response structure
                const fullName = data.data?.fullName || driverId; // Fallback to ID if no name found
                driverNameCache.set(driverId, fullName);
                return fullName;
            } catch (error) {
                console.error('Failed to fetch driver name:', error);
                return driverId; // Fallback to ID if API fails
            }
        }

        // Enhanced driver movement simulation
        function simulateDriverMovement(driverId) {
            if (!connection || connection.state !== signalR.HubConnectionState.Connected) return;

            // Initial position with some variation
            let lat = 24.7136 + (Math.random() * 0.1 - 0.05);
            let lng = 46.6753 + (Math.random() * 0.1 - 0.05);
            let heading = Math.random() * 360;

            // Update position every 3-5 seconds
            const interval = setInterval(() => {
                if (!driverConnections.has(driverId)) {
                    clearInterval(interval);
                    return;
                }

                // Calculate new position based on heading
                const distance = 0.001 + Math.random() * 0.002;
                lat += distance * Math.cos(heading * Math.PI / 180);
                lng += distance * Math.sin(heading * Math.PI / 180);

                // Random slight heading changes
                heading += (Math.random() * 30 - 15);

                // Send update with timestamp
                const timestamp = new Date().toISOString();
                connection.invoke("SendLocationUpdate", driverId, lat, lng)
                    .catch(err => console.error("Send failed:", err));

            }, 3000 + Math.random() * 2000);
        }

        // Enhanced driver position update with info window
        async function updateDriverPosition(driverId, lat, lng, timestamp) {
            const driverName = await getName(driverId);

            const position = { lat, lng };
            const colorIndex = parseInt(driverId.replace('R', '')) % colors.length;
            const color = colors[colorIndex];

            if (driverMarkers[driverId]) {
                // Update existing marker
                driverMarkers[driverId].setPosition(position);
                driverMarkers[driverId].setTitle(driverName);
                // Update info window content
                if (infoWindows[driverId]) {
                    infoWindows[driverId].setContent(createInfoWindowContent(driverName, driverId, lat, lng, timestamp));
                }
            } else {
                // Create new marker
                driverMarkers[driverId] = new google.maps.Marker({
                    position,
                    map,
                    title: driverName,
                    label: {
                        text: driverName,
                        color: 'white',
                        fontSize: '12px',
                        fontWeight: 'bold'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 10,
                        fillColor: color,
                        fillOpacity: 0.9,
                        strokeWeight: 2,
                        strokeColor: 'white'
                    },
                    animation: google.maps.Animation.DROP
                });

                // Create info window
                infoWindows[driverId] = new google.maps.InfoWindow({
                    content: createInfoWindowContent(driverName, driverId, lat, lng, timestamp)
                });

                // Add click listener to show info window
                driverMarkers[driverId].addListener("click", () => {
                    // Close all other info windows
                    Object.values(infoWindows).forEach(iw => iw.close());
                    infoWindows[driverId].open(map, driverMarkers[driverId]);
                });
            }
        }

        function createInfoWindowContent(driverName, driverId, lat, lng, timestamp) {
            const timeStr = timestamp ? new Date(timestamp).toLocaleTimeString() : 'Just now';
            return `
        <div class="driver-info-window">
            <div class="driver-info-title">${driverName}</div>
            <div><strong>Status:</strong> <span class="badge online-badge">Online</span></div>
            <div><strong>Last Update:</strong> ${timeStr}</div>
            <div><strong>Location:</strong></div>
            <div>Lat: ${lat.toFixed(6)}</div>
            <div>Lng: ${lng.toFixed(6)}</div>
            <div class="mt-2">
                <button onclick="centerOnDriver('${driverId}')" 
                        class="btn btn-sm btn-primary">Center Map</button>
            </div>
        </div>
    `;
        }

        // Center map on specific driver
        window.centerOnDriver = function (driverId) {
            if (driverMarkers[driverId]) {
                map.panTo(driverMarkers[driverId].getPosition());
                map.setZoom(15);
                if (infoWindows[driverId]) {
                    infoWindows[driverId].open(map, driverMarkers[driverId]);
                }
            }
        };

        function removeDriverMarker(driverId) {
            if (driverMarkers[driverId]) {
                driverMarkers[driverId].setMap(null);
                delete driverMarkers[driverId];
            }
            if (infoWindows[driverId]) {
                infoWindows[driverId].close();
                delete infoWindows[driverId];
            }
        }

        async function addOnlineDriver(driverId) {
            const list = document.getElementById("onlineDrivers");
            if (!Array.from(list.children).some(li => li.dataset.driverId === driverId)) {
                const li = document.createElement("li");
                li.className = "list-group-item d-flex justify-content-between align-items-center";
                li.dataset.driverId = driverId;
                li.innerHTML = `
            ${await getName(driverId)}
            <div>
                <span class="badge online-badge rounded-pill">Online</span>
                <button class="btn btn-sm btn-outline-primary ms-2" 
                        onclick="centerOnDriver('${driverId}')">Show</button>
            </div>
        `;
                list.appendChild(li);
            }
        }

        function removeOnlineDriver(driverId) {
            const list = document.getElementById("onlineDrivers");
            Array.from(list.children).forEach(li => {
                if (li.dataset.driverId === driverId) {
                    list.removeChild(li);
                }
            });
        }

        function updateConnectionStatus(status, alertClass) {
            const statusDiv = document.getElementById("connectionStatus");
            statusDiv.textContent = status;
            statusDiv.className = `alert ${alertClass} mb-3`;
        }

        function logMessage(message) {
            const logDiv = document.getElementById("logMessages");
            const entry = document.createElement("div");
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function showNotification(message) {
            const notification = document.createElement("div");
            notification.className = "alert alert-info position-fixed top-0 end-0 m-3";
            notification.style.zIndex = "1000";
            notification.style.width = "300px";
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 5000);
        }

        // Event listeners
        document.getElementById("connectBtn").addEventListener("click", () => {
            setupConnection();
            document.getElementById("connectBtn").disabled = true;
            logMessage("Connecting to tracking hub...");
        });

        document.getElementById("disconnectBtn").addEventListener("click", async () => {
            if (connection) {
                await connection.stop();
                driverConnections.clear();
                document.getElementById("onlineDrivers").innerHTML = '';
                Object.values(driverMarkers).forEach(marker => marker.setMap(null));
                Object.values(infoWindows).forEach(iw => iw.close());
                document.getElementById("connectBtn").disabled = false;
                document.getElementById("disconnectBtn").disabled = true;
                document.getElementById("broadcastBtn").disabled = true;
                updateConnectionStatus("Disconnected", "alert-danger");
                logMessage("Disconnected from hub");
            }
        });

        document.getElementById("broadcastBtn").addEventListener("click", async () => {
            const message = document.getElementById("broadcastMessage").value.trim();

            if (message) {
                try {
                    await connection.invoke("SendMessageToAllDrivers", message);
                    logMessage(`Broadcast message sent to all drivers`);
                    document.getElementById("broadcastMessage").value = '';
                } catch (err) {
                    logMessage(`Error broadcasting message: ${err}`);
                }
            }
        });
    </script>
</body>

</html>